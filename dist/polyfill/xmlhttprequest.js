const CLASSNAME = "XMLHttpRequest";
export class XMLHttpRequest {
    constructor() {
        this.requestHeaders = {};
        const METHOD_NAME = "constructor";
        console.log(CLASSNAME, METHOD_NAME, "ENTRY");
    }
    getAllResponseHeaders() {
        return this.responseHeadersRaw;
    }
    setRequestHeader(key, val) {
        const METHOD_NAME = "setRequestHeader";
        console.log(CLASSNAME, METHOD_NAME, "ENTRY", key, val);
        this.requestHeaders[key] = val;
    }
    open(method, url) {
        const METHOD_NAME = "open";
        console.log(CLASSNAME, METHOD_NAME, "ENTRY", method, url);
        this.method = method;
        this.url = url;
    }
    send(data) {
        const METHOD_NAME = "send";
        console.log(CLASSNAME, METHOD_NAME, "ENTRY", data);
        if (!this.url) {
            throw new Error("url is required");
        }
        if (!this.method) {
            throw new Error("method is required");
        }
        fetch(this.url, {
            method: this.method,
            headers: this.requestHeaders,
            body: data,
            timeout: this.timeout
        }).then(async (val) => {
            console.log(CLASSNAME, METHOD_NAME, "PROMISE.ENTRY", val);
            this.status = val.status;
            this.statusText = val.statusText;
            this.response = await val.text();
            this.responseHeadersRaw = "";
            val.headers.forEach((value, key) => {
                this.responseHeadersRaw += key + ": " + value + "\r\n";
            });
            console.log(CLASSNAME, METHOD_NAME, "PROMISE.RESULT", "this.status", this.status, "this.responseHeadersRaw", this.responseHeadersRaw);
            if (this.onload)
                this.onload();
        }).catch((reason) => {
            console.log('catching reason', reason);
            if (reason.code && (reason.code == 20 || reason.code == 23))
                reason.type = 'timeout';
            if (this.onerror) {
                this.onerror(reason);
                console.log("on error reason", reason);
            }
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieG1saHR0cHJlcXVlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcG9seWZpbGwveG1saHR0cHJlcXVlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0VBLE1BQU0sU0FBUyxHQUFHLGdCQUFnQixDQUFBO0FBQ2xDLE1BQU0sT0FBTyxjQUFjO0lBZXpCO1FBVkEsbUJBQWMsR0FBd0IsRUFBRSxDQUFBO1FBV3RDLE1BQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQTtRQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDOUMsQ0FBQztJQUVELHFCQUFxQjtRQUNuQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQTtJQUNoQyxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsR0FBVyxFQUFFLEdBQVE7UUFDcEMsTUFBTSxXQUFXLEdBQUcsa0JBQWtCLENBQUE7UUFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUE7UUFDdEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUE7SUFDaEMsQ0FBQztJQUVELElBQUksQ0FBQyxNQUFjLEVBQUUsR0FBVztRQUM5QixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUE7UUFDMUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUE7UUFFekQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7UUFDcEIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUE7SUFDaEIsQ0FBQztJQUVELElBQUksQ0FBQyxJQUFTO1FBQ1osTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFBO1FBQzFCLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUE7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtRQUNwQyxDQUFDO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUE7UUFDdkMsQ0FBQztRQUVELEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ2QsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLE9BQU8sRUFBRSxJQUFJLENBQUMsY0FBYztZQUM1QixJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztTQUN0QixDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFhLEVBQUUsRUFBRTtZQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLEdBQUcsQ0FBQyxDQUFBO1lBRXpELElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQTtZQUN4QixJQUFJLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUE7WUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtZQUdoQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsRUFBRSxDQUFBO1lBQzVCLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBYSxFQUFFLEdBQVcsRUFBRSxFQUFFO2dCQUNqRCxJQUFJLENBQUMsa0JBQWtCLElBQUksR0FBRyxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsTUFBTSxDQUFBO1lBQ3hELENBQUMsQ0FBQyxDQUFBO1lBQ0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUM1RSx5QkFBeUIsRUFDekIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUE7WUFDNUIsSUFBSSxJQUFJLENBQUMsTUFBTTtnQkFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUE7UUFDaEMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBVyxFQUFFLEVBQUU7WUFDdkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsQ0FBQTtZQUd0QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFBRSxNQUFNLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQTtZQUVwRixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUMsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQTtnQkFDcEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsQ0FBQTtZQUN4QyxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0NBRUYiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXG52YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICAgICAgICAgICAgdmFyIGssIHRtcCwgYXJyLCBzdHI9b3B0cy5ib2R5O1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG5cbiAgICAgICAgICAgIC8vIElFIGNvbXBhdGlibGVcbiAgICAgICAgICAgIGlmIChvcHRzLnRpbWVvdXQpIHJlcS50aW1lb3V0ID0gb3B0cy50aW1lb3V0O1xuICAgICAgICAgICAgcmVxLm9udGltZW91dCA9IHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGVyci50aW1lb3V0ID0gZXJyLnR5cGUgPT0gJ3RpbWVvdXQnO1xuICAgICAgICAgICAgICAgIHJlaihlcnIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxLm9wZW4obWV0aG9kLCB1cmkuaHJlZiB8fCB1cmkpO1xuXG4gICAgICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFyciA9IHJlcS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS50cmltKCkuc3BsaXQoL1tcXHJcXG5dKy8pO1xuICAgICAgICAgICAgICAgIGFwcGx5KHJlcSwgcmVxKTsgLy89PiByZXEuaGVhZGVyc1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRtcCA9IGFyci5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5zcGxpdCgnOiAnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmhlYWRlcnNbdG1wLnNoaWZ0KCkudG9Mb3dlckNhc2UoKV0gPSB0bXAuam9pbignOiAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0bXAgPSByZXEuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICAgICAgICAgICAgaWYgKHRtcCAmJiAhIX50bXAuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZGF0YSA9IEpTT04ucGFyc2UocmVxLmRhdGEsIG9wdHMucmV2aXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHkocmVxLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlaihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgKHJlcS5zdGF0dXMgPj0gNDAwID8gcmVqIDogcmVzKShyZXEpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBGb3JtRGF0YSA8ICd1JyAmJiBzdHIgaW5zdGFuY2VvZiBGb3JtRGF0YSkgOyBlbHNlIGlmIChzdHIgJiYgdHlwZW9mIHN0ciA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KHN0cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICAgICAgICBmb3IgKGsgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGssIGhlYWRlcnNba10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXEuc2VuZChzdHIpO1xuKi9cbi8qXG50eXBlIHh4ID0ge1xuICAgIFtpbmRleDogc3RyaW5nXTogc3RyaW5nO1xufSovXG5cbi8vbG9va2VkIGdvb2QgYnV0IGRvZXMgbm90IHdvcmsgOihcbi8vaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UveG1saHR0cHJlcXVlc3QtdHNcbi8vaW1wb3J0cyBub2RlIHR5cGVzIHRoYXQgY29uZmxpY3Qgd2l0aCBkY2wgY29uc29sZT8/P1xuLy9odHRwczovL2RlY2VudHJhbGFuZHRlYW0uc2xhY2suY29tL2FyY2hpdmVzL0MwMjkyUDRISjkzL3AxNjgzNzQ5NzIyMjQxOTE5XG4vL2ltcG9ydCB7IFhNTEh0dHBSZXF1ZXN0IH0gZnJvbSAneG1saHR0cHJlcXVlc3QtdHMnO1xuLy93cml0aW5nIG15IG93blxuXG4vL2NvbnN0IG15eDp4eCA9IHsyOiAncyd9XG5cbmNvbnN0IENMQVNTTkFNRSA9IFwiWE1MSHR0cFJlcXVlc3RcIlxuZXhwb3J0IGNsYXNzIFhNTEh0dHBSZXF1ZXN0IHtcbiAgb250aW1lb3V0PzogKGVycjogYW55KSA9PiB2b2lkXG4gIG9uZXJyb3I/OiAoZXJyOiBhbnkpID0+IHZvaWRcbiAgb25sb2FkPzogKCkgPT4gdm9pZFxuICB3aXRoQ3JlZGVudGlhbHM6IGFueS8vPz8/XG4gIHJlcXVlc3RIZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgdGltZW91dD86IG51bWJlclxuXG4gIC8vcmVzcG9uc2VIZWFkZXJzOlJlY29yZDxzdHJpbmcsYW55Pj17fVxuICByZXNwb25zZUhlYWRlcnNSYXc/OiBzdHJpbmdcbiAgc3RhdHVzPzogbnVtYmVyXG4gIHN0YXR1c1RleHQ/OiBzdHJpbmdcbiAgcmVzcG9uc2U/OiBhbnlcbiAgdXJsPzogc3RyaW5nXG4gIG1ldGhvZD86IHN0cmluZ1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBNRVRIT0RfTkFNRSA9IFwiY29uc3RydWN0b3JcIlxuICAgIGNvbnNvbGUubG9nKENMQVNTTkFNRSwgTUVUSE9EX05BTUUsIFwiRU5UUllcIilcbiAgfVxuXG4gIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZUhlYWRlcnNSYXdcbiAgfVxuXG4gIHNldFJlcXVlc3RIZWFkZXIoa2V5OiBzdHJpbmcsIHZhbDogYW55KSB7XG4gICAgY29uc3QgTUVUSE9EX05BTUUgPSBcInNldFJlcXVlc3RIZWFkZXJcIlxuICAgIGNvbnNvbGUubG9nKENMQVNTTkFNRSwgTUVUSE9EX05BTUUsIFwiRU5UUllcIiwga2V5LCB2YWwpXG4gICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1trZXldID0gdmFsXG4gIH1cblxuICBvcGVuKG1ldGhvZDogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICAgIGNvbnN0IE1FVEhPRF9OQU1FID0gXCJvcGVuXCJcbiAgICBjb25zb2xlLmxvZyhDTEFTU05BTUUsIE1FVEhPRF9OQU1FLCBcIkVOVFJZXCIsIG1ldGhvZCwgdXJsKVxuICAgIC8vcHJlcGFyZXMgb3BlblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgfVxuXG4gIHNlbmQoZGF0YTogYW55KSB7XG4gICAgY29uc3QgTUVUSE9EX05BTUUgPSBcInNlbmRcIlxuICAgIGNvbnNvbGUubG9nKENMQVNTTkFNRSwgTUVUSE9EX05BTUUsIFwiRU5UUllcIiwgZGF0YSlcbiAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cmwgaXMgcmVxdWlyZWRcIilcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1ldGhvZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGlzIHJlcXVpcmVkXCIpXG4gICAgfVxuICAgIC8vZG9lcyB0aGUgYWN0dWFsIG9wZW5cbiAgICBmZXRjaCh0aGlzLnVybCwge1xuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHRoaXMucmVxdWVzdEhlYWRlcnMsIC8vcHJldHR5IHN1cmUgUmVjb3JkPHN0cmluZyxzdHJpbmc+ID09IHsgW2luZGV4OiBzdHJpbmddOiBzdHJpbmcgfVxuICAgICAgYm9keTogZGF0YSxcbiAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dFxuICAgIH0pLnRoZW4oYXN5bmMgKHZhbDogUmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKENMQVNTTkFNRSwgTUVUSE9EX05BTUUsIFwiUFJPTUlTRS5FTlRSWVwiLCB2YWwpXG5cbiAgICAgIHRoaXMuc3RhdHVzID0gdmFsLnN0YXR1c1xuICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gdmFsLnN0YXR1c1RleHRcbiAgICAgIHRoaXMucmVzcG9uc2UgPSBhd2FpdCB2YWwudGV4dCgpIC8vbmVlZCB0byBkbyBhc3luY1xuICAgICAgLy9tdXN0IHR1cm4gdGhpcyBpbnRvIHJhdyB2ZXJzaW9uXG5cbiAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzUmF3ID0gXCJcIlxuICAgICAgdmFsLmhlYWRlcnMuZm9yRWFjaCgodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnNSYXcgKz0ga2V5ICsgXCI6IFwiICsgdmFsdWUgKyBcIlxcclxcblwiXG4gICAgICB9KVxuICAgICAgY29uc29sZS5sb2coQ0xBU1NOQU1FLCBNRVRIT0RfTkFNRSwgXCJQUk9NSVNFLlJFU1VMVFwiLCBcInRoaXMuc3RhdHVzXCIsIHRoaXMuc3RhdHVzXG4gICAgICAgICwgXCJ0aGlzLnJlc3BvbnNlSGVhZGVyc1Jhd1wiXG4gICAgICAgICwgdGhpcy5yZXNwb25zZUhlYWRlcnNSYXcpXG4gICAgICBpZiAodGhpcy5vbmxvYWQpIHRoaXMub25sb2FkKClcbiAgICB9KS5jYXRjaCgocmVhc29uOiBhbnkpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdjYXRjaGluZyByZWFzb24nLCByZWFzb24pXG4gICAgICAvL2NvbHlzZXN1cyB3YW50ZWQgdGhpcyAnZXJyLnRpbWVvdXQgPSBlcnIudHlwZSA9PSAndGltZW91dCc7J1xuICAgICAgLy8yMCA9PSBhYm9ydCwgMjMgPT0gdGltZW91dC8vXG4gICAgICBpZiAocmVhc29uLmNvZGUgJiYgKHJlYXNvbi5jb2RlID09IDIwIHx8IHJlYXNvbi5jb2RlID09IDIzKSkgcmVhc29uLnR5cGUgPSAndGltZW91dCdcblxuICAgICAgaWYgKHRoaXMub25lcnJvcil7XG4gICAgICAgIHRoaXMub25lcnJvcihyZWFzb24pXG4gICAgICAgIGNvbnNvbGUubG9nKFwib24gZXJyb3IgcmVhc29uXCIsIHJlYXNvbilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbn0iXX0=